-lvalue vs rvalue
ref: http://thbecker.net/articles/rvalue_references/section_01.html

lvalue could be at both left and right side of assignment operator(=) but rvalue could only be at right side
lvalue's address can be access via & operator, otherwise it's rvalue
a declared rvalue could be both lvalue and rvalue. If it has a name, it's a lvalue, otherwise rvalue.
   ex:
   void foo(X && x) {
       X obj = x; // calling X(const X &rhs) - it has a name, it's lvalue even declared as rvalue
   }

   X&& go();
   X obj = go(); // calling X(X && rhs) - it has no name, rvalue

-std::move()
    turns argument into a rvalue even if it's not, by hiding name

    SubClass(SubClass && rhs)
        : Base(std::move(rhs) {
        }

-std::forward()
forwarding problem: lval or rval attribute might gets changed while forwarding as parameter.using std::forward will keep this attribute.

example:

    class Test {

    public:
        Test(){}

        Test(const Test&) {
            cout << "copy ctor" << endl;
        }
        Test(Test&&) {
            cout << "move ctor" << endl;
        }
    };
    
 
    template <typename T>
    void func(T t) {
    }

    template <typename T>
    void func2(T&& t) {
        func(t); // t is always lvalue and copy ctor is called
    }

    template <typename T>
    void func3(T&& t) {
        func(std::forward<T>(t)); // t's lval or rval attribute keeps unchanged. So copy ctor or move ctor could be called.
    }

-universal reference
  defined by Scott Meyes at: http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11
  1. T&&
  2. Type of T defined via deduction
  try perfect forward as much as possible in this case:
  template <typename T>
  void doSomething(T&& t) {
      do(std::forward<T>(t));
  }

-std::initializer_list
used to access list initialized by braces.

int sum(const std::initializer_list<int> & list) {  
  int s = 0;
  for (const auto &i : list) {
    s += i;
  }
  return s;
}
std::cout << "{1, 3, 5} = " << sum({1,3,5}) << std::endl; //output: {1, 3, 5} = 9

- Top level const : pointer itself is const
- low level const : when a pointer points to const object
example:
int n = 0;
const int *p1 = &n; // low level - pointer to const int
int *const p2 = &n; // top level - const pointer to int
const int c_int = 1; // top level
const int& c_ref = n; // low level

- auto : auto deduce type from initializing expression, if expression is reference or there is top level const/volatile, they are ignored.

int x = 1;
const int *p = &x; // low level const
auto p2 = p; // const not removed
*p2 = 2; // error

const int i = 0;
auto& r_i = i;
r_i = 1; // error: const qualifier was not removed

int i = 1;
auto&& ri_1 = i; // i is lvalue, int & is deduced -> int & && : collapsed to int &
auto&& ri_2 = 2; // 2 is rvalue, no additional addons -> int &&

- decltype
basics: to inspect exact declared type of an expression.
example:
int a = 0;
decltype(a) b = a;
template <typename T, typename S>
auto calc(T t, S s) -> decltype(t * s) {
   return t*s;
}

auto f = [](int a, int b) -> int {
   return a + b;
}
decltype(f) g = f;
g(1, 3) // 4

//forward unknown return value to another function
template <typename T1, typename T2>
void func(T1 t1, T2 t2) {
   auto && r = f1();
   f2(std::forward<decltype(f2())>(r));
}

// decltype add reference, 
// The following example, which was provided by Stephan Lavavej, demonstrates that:
template <typename T>
auto array_access(T& array, size_t pos) -> decltype(array[pos]) {
  return array[pos];
}

std::vector<int> vect = {42, 43, 44};
int* p = &vect[0];

array_access(vect, 2) = 45;
array_access(p, 2) = 46;

nullptr:
 nullptr is of type std::nullptr_t and could be converted to any pointer type.
 NULL is old MACRO defined 0, which has ambigous between 0 and (void *)0.
void f(char *){}
void f(int) {}
void g(int) {}
  
f(nullptr);
f(NULL);// error, ambiguous
f(0);
g(NULL);//warning, passing NULL to non-pointer type
