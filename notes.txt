-lvalue vs rvalue
ref: http://thbecker.net/articles/rvalue_references/section_01.html

lvalue could be at both left and right side of assignment operator(=) but rvalue could only be at right side
lvalue's address can be access via & operator, otherwise it's rvalue
a declared rvalue could be both lvalue and rvalue. If it has a name, it's a lvalue, otherwise rvalue.
   ex:
   void foo(X && x) {
       X obj = x; // calling X(const X &rhs) - it has a name, it's lvalue even declared as rvalue
   }

   X&& go();
   X obj = go(); // calling X(X && rhs) - it has no name, rvalue

-std::move()
    turns argument into a rvalue even if it's not, by hiding name

    SubClass(SubClass && rhs)
        : Base(std::move(rhs) {
        }

-std::forward()
forwarding problem: lval or rval attribute might gets changed while forwarding as parameter.using std::forward will keep this attribute.

example:

    class Test {

    public:
        Test(){}

        Test(const Test&) {
            cout << "copy ctor" << endl;
        }
        Test(Test&&) {
            cout << "move ctor" << endl;
        }
    };

    template <typename T>
    void func(T t) {
    }

    template <typename T>
    void func2(T&& t) {
        func(t); // t is always lvalue and copy ctor is called
    }

    template <typename T>
    void func3(T&& t) {
        func(std::forward<T>(t)); // t's lval or rval attribute keeps unchanged. So copy ctor or move ctor could be called.
    }

-universal reference
  defined by Scott Meyes at: http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11
  1. T&&
  2. Type of T defined via deduction
  try perfect forward as much as possible in this case:
  template <typename T>
  void doSomething(T&& t) {
      do(std::forward<T>(t));
  }

-std::initializer_list
used to access list initialized by braces.

int sum(const std::initializer_list<int> & list) {  
  int s = 0;
  for (const auto &i : list) {
    s += i;
  }
  return s;
}
std::cout << "{1, 3, 5} = " << sum({1,3,5}) << std::endl; //output: {1, 3, 5} = 9

